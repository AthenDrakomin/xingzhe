import{r as w,R as Nt}from"./vendor-KfUPlHYY.js";import{f as at,i as xt,h as ne,T as $,k as Ft,c as H,q as it,l as se,w as re,g as ct,o as Wt,d as T}from"./index-C51D2hFb.js";var oe={exports:{}},ae={};/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var st=w;function Se(t,e){return t===e&&(t!==0||1/t===1/e)||t!==t&&e!==e}var ve=typeof Object.is=="function"?Object.is:Se,Ae=st.useState,ye=st.useEffect,De=st.useLayoutEffect,Oe=st.useDebugValue;function be(t,e){var n=e(),s=Ae({inst:{value:n,getSnapshot:e}}),r=s[0].inst,c=s[1];return De(function(){r.value=n,r.getSnapshot=e,Rt(r)&&c({inst:r})},[t,n,e]),ye(function(){return Rt(r)&&c({inst:r}),t(function(){Rt(r)&&c({inst:r})})},[t]),Oe(n),n}function Rt(t){var e=t.getSnapshot;t=t.value;try{var n=e();return!ve(t,n)}catch{return!0}}function Te(t,e){return e()}var _e=typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"?Te:be;ae.useSyncExternalStore=st.useSyncExternalStore!==void 0?st.useSyncExternalStore:_e;oe.exports=ae;var Jt=oe.exports;const ie=0,ce=1,ue=2,Yt=3;var Xt=Object.prototype.hasOwnProperty;function bt(t,e){var n,s;if(t===e)return!0;if(t&&e&&(n=t.constructor)===e.constructor){if(n===Date)return t.getTime()===e.getTime();if(n===RegExp)return t.toString()===e.toString();if(n===Array){if((s=t.length)===e.length)for(;s--&&bt(t[s],e[s]););return s===-1}if(!n||typeof t=="object"){s=0;for(n in t)if(Xt.call(t,n)&&++s&&!Xt.call(e,n)||!(n in e)||!bt(t[n],e[n]))return!1;return Object.keys(e).length===s}}return t!==t&&e!==e}const M=new WeakMap,U=()=>{},A=U(),Tt=Object,i=t=>t===A,W=t=>typeof t=="function",k=(t,e)=>({...t,...e}),de=t=>W(t.then),St={},ht={},Pt="undefined",ut=typeof window!=Pt,_t=typeof document!=Pt,Ce=ut&&"Deno"in window,Ie=()=>ut&&typeof window.requestAnimationFrame!=Pt,le=(t,e)=>{const n=M.get(t);return[()=>!i(e)&&t.get(e)||St,s=>{if(!i(e)){const r=t.get(e);e in ht||(ht[e]=r),n[5](e,k(r,s),r||St)}},n[6],()=>!i(e)&&e in ht?ht[e]:!i(e)&&t.get(e)||St]};let Ct=!0;const Le=()=>Ct,[It,Lt]=ut&&window.addEventListener?[window.addEventListener.bind(window),window.removeEventListener.bind(window)]:[U,U],Ve=()=>{const t=_t&&document.visibilityState;return i(t)||t!=="hidden"},qe=t=>(_t&&document.addEventListener("visibilitychange",t),It("focus",t),()=>{_t&&document.removeEventListener("visibilitychange",t),Lt("focus",t)}),Ne=t=>{const e=()=>{Ct=!0,t()},n=()=>{Ct=!1};return It("online",e),It("offline",n),()=>{Lt("online",e),Lt("offline",n)}},xe={isOnline:Le,isVisible:Ve},Fe={initFocus:qe,initReconnect:Ne},Qt=!Nt.useId,nt=!ut||Ce,We=t=>Ie()?window.requestAnimationFrame(t):setTimeout(t,1),vt=nt?w.useEffect:w.useLayoutEffect,At=typeof navigator<"u"&&navigator.connection,Zt=!nt&&At&&(["slow-2g","2g"].includes(At.effectiveType)||At.saveData),gt=new WeakMap,Pe=t=>Tt.prototype.toString.call(t),yt=(t,e)=>t===`[object ${e}]`;let je=0;const Vt=t=>{const e=typeof t,n=Pe(t),s=yt(n,"Date"),r=yt(n,"RegExp"),c=yt(n,"Object");let a,u;if(Tt(t)===t&&!s&&!r){if(a=gt.get(t),a)return a;if(a=++je+"~",gt.set(t,a),Array.isArray(t)){for(a="@",u=0;u<t.length;u++)a+=Vt(t[u])+",";gt.set(t,a)}if(c){a="#";const p=Tt.keys(t).sort();for(;!i(u=p.pop());)i(t[u])||(a+=u+":"+Vt(t[u])+",");gt.set(t,a)}}else a=s?t.toJSON():e=="symbol"?t.toString():e=="string"?JSON.stringify(t):""+t;return a},jt=t=>{if(W(t))try{t=t()}catch{t=""}const e=t;return t=typeof t=="string"?t:(Array.isArray(t)?t.length:t)?Vt(t):"",[t,e]};let Me=0;const qt=()=>++Me;async function fe(...t){const[e,n,s,r]=t,c=k({populateCache:!0,throwOnError:!0},typeof r=="boolean"?{revalidate:r}:r||{});let a=c.populateCache;const u=c.rollbackOnError;let p=c.optimisticData;const C=y=>typeof u=="function"?u(y):u!==!1,S=c.throwOnError;if(W(n)){const y=n,v=[],O=e.keys();for(const I of O)!/^\$(inf|sub)\$/.test(I)&&y(e.get(I)._k)&&v.push(I);return Promise.all(v.map(m))}return m(n);async function m(y){const[v]=jt(y);if(!v)return;const[O,I]=le(e,v),[q,rt,o,dt]=M.get(e),G=()=>{const L=q[v];return(W(c.revalidate)?c.revalidate(O().data,y):c.revalidate!==!1)&&(delete o[v],delete dt[v],L&&L[0])?L[0](ue).then(()=>O().data):O().data};if(t.length<3)return G();let E=s,N,x=!1;const J=qt();rt[v]=[J,0];const l=!i(p),Y=O(),F=Y.data,X=Y._c,B=i(X)?F:X;if(l&&(p=W(p)?p(B,F):p,I({data:p,_c:B})),W(E))try{E=E(B)}catch(L){N=L,x=!0}if(E&&de(E))if(E=await E.catch(L=>{N=L,x=!0}),J!==rt[v][0]){if(x)throw N;return E}else x&&l&&C(N)&&(a=!0,I({data:B,_c:A}));if(a&&!x)if(W(a)){const L=a(E,B);I({data:L,error:A,_c:A})}else I({data:E,error:A,_c:A});if(rt[v][1]=qt(),Promise.resolve(G()).then(()=>{I({_c:A})}),x){if(S)throw N;return}return E}}const te=(t,e)=>{for(const n in t)t[n][0]&&t[n][0](e)},Ue=(t,e)=>{if(!M.has(t)){const n=k(Fe,e),s=Object.create(null),r=fe.bind(A,t);let c=U;const a=Object.create(null),u=(S,m)=>{const y=a[S]||[];return a[S]=y,y.push(m),()=>y.splice(y.indexOf(m),1)},p=(S,m,y)=>{t.set(S,m);const v=a[S];if(v)for(const O of v)O(m,y)},C=()=>{if(!M.has(t)&&(M.set(t,[s,Object.create(null),Object.create(null),Object.create(null),r,p,u]),!nt)){const S=n.initFocus(setTimeout.bind(A,te.bind(A,s,ie))),m=n.initReconnect(setTimeout.bind(A,te.bind(A,s,ce)));c=()=>{S&&S(),m&&m(),M.delete(t)}}};return C(),[t,r,C,c]}return[t,M.get(t)[4]]},$e=(t,e,n,s,r)=>{const c=n.errorRetryCount,a=r.retryCount,u=~~((Math.random()+.5)*(1<<(a<8?a:8)))*n.errorRetryInterval;!i(c)&&a>c||setTimeout(s,u,r)},He=bt,[pe,ke]=Ue(new Map),Be=k({onLoadingSlow:U,onSuccess:U,onError:U,onErrorRetry:$e,onDiscarded:U,revalidateOnFocus:!0,revalidateOnReconnect:!0,revalidateIfStale:!0,shouldRetryOnError:!0,errorRetryInterval:Zt?1e4:5e3,focusThrottleInterval:5*1e3,dedupingInterval:2*1e3,loadingTimeout:Zt?5e3:3e3,compare:He,isPaused:()=>!1,cache:pe,mutate:ke,fallback:{}},xe),ze=(t,e)=>{const n=k(t,e);if(e){const{use:s,fallback:r}=t,{use:c,fallback:a}=e;s&&c&&(n.use=s.concat(c)),r&&a&&(n.fallback=k(r,a))}return n},Ke=w.createContext({}),Ge="$inf$",he=ut&&window.__SWR_DEVTOOLS_USE__,Je=he?window.__SWR_DEVTOOLS_USE__:[],Ye=()=>{he&&(window.__SWR_DEVTOOLS_REACT__=Nt)},Xe=t=>W(t[1])?[t[0],t[1],t[2]||{}]:[t[0],null,(t[1]===null?t[2]:t[1])||{}],Qe=()=>{const t=w.useContext(Ke);return w.useMemo(()=>k(Be,t),[t])},Ze=t=>(e,n,s)=>t(e,n&&((...c)=>{const[a]=jt(e),[,,,u]=M.get(pe);if(a.startsWith(Ge))return n(...c);const p=u[a];return i(p)?n(...c):(delete u[a],p)}),s),tn=Je.concat(Ze),en=t=>function(...n){const s=Qe(),[r,c,a]=Xe(n),u=ze(s,a);let p=t;const{use:C}=u,S=(C||[]).concat(tn);for(let m=S.length;m--;)p=S[m](p);return p(r,c||u.fetcher||null,u)},nn=(t,e,n)=>{const s=e[t]||(e[t]=[]);return s.push(n),()=>{const r=s.indexOf(n);r>=0&&(s[r]=s[s.length-1],s.pop())}};Ye();const Dt=Nt.use||(t=>{switch(t.status){case"pending":throw t;case"fulfilled":return t.value;case"rejected":throw t.reason;default:throw t.status="pending",t.then(e=>{t.status="fulfilled",t.value=e},e=>{t.status="rejected",t.reason=e}),t}}),Ot={dedupe:!0},ee=Promise.resolve(A),sn=(t,e,n)=>{const{cache:s,compare:r,suspense:c,fallbackData:a,revalidateOnMount:u,revalidateIfStale:p,refreshInterval:C,refreshWhenHidden:S,refreshWhenOffline:m,keepPreviousData:y,strictServerPrefetchWarning:v}=n,[O,I,q,rt]=M.get(s),[o,dt]=jt(t),G=w.useRef(!1),E=w.useRef(!1),N=w.useRef(o),x=w.useRef(e),J=w.useRef(n),l=()=>J.current,Y=()=>l().isVisible()&&l().isOnline(),[F,X,B,L]=le(s,o),Q=w.useRef({}).current,lt=i(a)?i(n.fallback)?A:n.fallback[o]:a,Mt=(d,f)=>{for(const g in Q){const h=g;if(h==="data"){if(!r(d[h],f[h])&&(!i(d[h])||!r(pt,f[h])))return!1}else if(f[h]!==d[h])return!1}return!0},Ut=w.useMemo(()=>{const d=!o||!e?!1:i(u)?l().isPaused()||c?!1:p!==!1:u,f=D=>{const P=k(D);return delete P._k,d?{isValidating:!0,isLoading:!0,...P}:P},g=F(),h=L(),V=f(g),et=g===h?V:f(h);let R=V;return[()=>{const D=f(F());return Mt(D,R)?(R.data=D.data,R.isLoading=D.isLoading,R.isValidating=D.isValidating,R.error=D.error,R):(R=D,D)},()=>et]},[s,o]),Z=Jt.useSyncExternalStore(w.useCallback(d=>B(o,(f,g)=>{Mt(g,f)||d()}),[s,o]),Ut[0],Ut[1]),$t=!G.current,ge=O[o]&&O[o].length>0,tt=Z.data,z=i(tt)?lt&&de(lt)?Dt(lt):lt:tt,ft=Z.error,wt=w.useRef(z),pt=y?i(tt)?i(wt.current)?z:wt.current:tt:z,K=o&&i(z),we=!nt&&Jt.useSyncExternalStore(()=>U,()=>!1,()=>!0);v&&we&&!c&&K&&console.warn(`Missing pre-initiated data for serialized key "${o}" during server-side rendering. Data fethcing should be initiated on the server and provided to SWR via fallback data. You can set "strictServerPrefetchWarning: false" to disable this warning.`);const Ht=ge&&!i(ft)?!1:$t&&!i(u)?u:l().isPaused()?!1:c?i(z)?!1:p:i(z)||p,kt=!!(o&&e&&$t&&Ht),me=i(Z.isValidating)?kt:Z.isValidating,Ee=i(Z.isLoading)?kt:Z.isLoading,ot=w.useCallback(async d=>{const f=x.current;if(!o||!f||E.current||l().isPaused())return!1;let g,h,V=!0;const et=d||{},R=!q[o]||!et.dedupe,D=()=>Qt?!E.current&&o===N.current&&G.current:o===N.current,P={isValidating:!1,isLoading:!1},zt=()=>{X(P)},Kt=()=>{const _=q[o];_&&_[1]===h&&delete q[o]},Gt={isValidating:!0};i(F().data)&&(Gt.isLoading=!0);try{if(R&&(X(Gt),n.loadingTimeout&&i(F().data)&&setTimeout(()=>{V&&D()&&l().onLoadingSlow(o,n)},n.loadingTimeout),q[o]=[f(dt),qt()]),[g,h]=q[o],g=await g,R&&setTimeout(Kt,n.dedupingInterval),!q[o]||q[o][1]!==h)return R&&D()&&l().onDiscarded(o),!1;P.error=A;const _=I[o];if(!i(_)&&(h<=_[0]||h<=_[1]||_[1]===0))return zt(),R&&D()&&l().onDiscarded(o),!1;const j=F().data;P.data=r(j,g)?j:g,R&&D()&&l().onSuccess(g,o,n)}catch(_){Kt();const j=l(),{shouldRetryOnError:mt}=j;j.isPaused()||(P.error=_,R&&D()&&(j.onError(_,o,j),(mt===!0||W(mt)&&mt(_))&&(!l().revalidateOnFocus||!l().revalidateOnReconnect||Y())&&j.onErrorRetry(_,o,j,Re=>{const Et=O[o];Et&&Et[0]&&Et[0](Yt,Re)},{retryCount:(et.retryCount||0)+1,dedupe:!0})))}return V=!1,zt(),!0},[o,s]),Bt=w.useCallback((...d)=>fe(s,N.current,...d),[]);if(vt(()=>{x.current=e,J.current=n,i(tt)||(wt.current=tt)}),vt(()=>{if(!o)return;const d=ot.bind(A,Ot);let f=0;l().revalidateOnFocus&&(f=Date.now()+l().focusThrottleInterval);const h=nn(o,O,(V,et={})=>{if(V==ie){const R=Date.now();l().revalidateOnFocus&&R>f&&Y()&&(f=R+l().focusThrottleInterval,d())}else if(V==ce)l().revalidateOnReconnect&&Y()&&d();else{if(V==ue)return ot();if(V==Yt)return ot(et)}});return E.current=!1,N.current=o,G.current=!0,X({_k:dt}),Ht&&(q[o]||(i(z)||nt?d():We(d))),()=>{E.current=!0,h()}},[o]),vt(()=>{let d;function f(){const h=W(C)?C(F().data):C;h&&d!==-1&&(d=setTimeout(g,h))}function g(){!F().error&&(S||l().isVisible())&&(m||l().isOnline())?ot(Ot).then(f):f()}return f(),()=>{d&&(clearTimeout(d),d=-1)}},[C,S,m,o]),w.useDebugValue(pt),c){if(!Qt&&nt&&K)throw new Error("Fallback data is required when using Suspense in SSR.");K&&(x.current=e,J.current=n,E.current=!1);const d=rt[o],f=!i(d)&&K?Bt(d):ee;if(Dt(f),!i(ft)&&K)throw ft;const g=K?ot(Ot):ee;!i(pt)&&K&&(g.status="fulfilled",g.value=!0),Dt(g)}return{mutate:Bt,get data(){return Q.data=!0,pt},get error(){return Q.error=!0,ft},get isValidating(){return Q.isValidating=!0,me},get isLoading(){return Q.isLoading=!0,Ee}}},cn=en(sn),b=t=>t instanceof $?t.toDate():t,un={getAll:async()=>{const t=it(H(T,"articles"),Wt("publishedAt","desc"));return(await ct(t)).docs.map(n=>{const s=n.data();return{id:n.id,...s,createdAt:b(s.createdAt),updatedAt:s.updatedAt?b(s.updatedAt):void 0,publishedAt:s.publishedAt?b(s.publishedAt):void 0}})},getBySlug:async t=>{const e=it(H(T,"articles"),re("slug","==",t),se(1)),n=await ct(e);if(n.empty)return null;const s=n.docs[0],r=s.data();return{id:s.id,...r,createdAt:b(r.createdAt),updatedAt:r.updatedAt?b(r.updatedAt):void 0,publishedAt:r.publishedAt?b(r.publishedAt):void 0}},create:async(t,e)=>(await Ft(H(T,"articles"),{...t,author:e,createdAt:$.now(),updatedAt:$.now(),views:0})).id,update:async(t,e)=>{const n=at(T,"articles",t);await ne(n,{...e,updatedAt:$.now()})},delete:async t=>{const e=at(T,"articles",t);await xt(e)}},dn={getAll:async()=>{const t=it(H(T,"pages"),Wt("order","asc"));return(await ct(t)).docs.map(n=>{const s=n.data();return{id:n.id,...s,createdAt:b(s.createdAt),updatedAt:b(s.updatedAt),publishedAt:s.publishedAt?b(s.publishedAt):void 0}})},getBySlug:async t=>{const e=it(H(T,"pages"),re("slug","==",t),se(1)),n=await ct(e);if(n.empty)return null;const s=n.docs[0],r=s.data();return{id:s.id,...r,createdAt:b(r.createdAt),updatedAt:b(r.updatedAt),publishedAt:r.publishedAt?b(r.publishedAt):void 0}},create:async t=>(await Ft(H(T,"pages"),{...t,createdAt:$.now(),updatedAt:$.now()})).id,update:async(t,e)=>{const n=at(T,"pages",t);await ne(n,{...e,updatedAt:$.now()})},delete:async t=>{const e=at(T,"pages",t);await xt(e)}},ln={create:async t=>(await Ft(H(T,"media"),{...t,createdAt:$.now()})).id,getAll:async()=>{const t=it(H(T,"media"),Wt("createdAt","desc"));return(await ct(t)).docs.map(n=>{const s=n.data();return{id:n.id,...s,createdAt:b(s.createdAt)}})},delete:async t=>{const e=at(T,"media",t);await xt(e)}};export{un as a,ln as m,dn as p,cn as u};
